<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Construct reproducible analytic data sets as R packages • DataPackageR</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="pkgdown.css" rel="stylesheet">
<script src="jquery.sticky-kit.min.js"></script><script src="pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DataPackageR</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="/index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    

    
    
<div class="contents">
<!-- README.md is generated from README.Rmd. Please edit that file -->
<div id="datapackager" class="section level1">
<div class="page-header"><h1 class="hasAnchor">
<a href="#datapackager" class="anchor"></a>DataPackageR</h1></div>
<p>Process raw data into packaged, analysis-ready data sets, reproducibly.</p>
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>A data set may consist of multiple sources of raw data. These need to be cleaned, standardized, QCd, and any number of other manipulations applied before they are ready for analysis.</p>
<p>This package is designed to simplify and centralize tasks associated with tidying a variety of data sets associated with a single project.</p>
<p>It provides a mechanism to collect, organize and version the data munging scripts used to process incoming data into analytical data sets. The package runs these scripts to perform the data munging writes out analytical data sets, which are combined with documentation, and built into a new R package. The package and the included data are versioned. If updated data arrive, the package can be rebuilt, and the data version incremented to reflect the changes. If the data munging code is in the form of Rmarkdown documents, these are processed automatically into package vignettes that are included in the final pacakge.</p>
<p>No other restrictions are placed on the data munging code.</p>
</div>
<div id="usage" class="section level2">
<h2 class="hasAnchor">
<a href="#usage" class="anchor"></a>Usage</h2>
<p>Set up a new data package. Assume we have data munging code in <code>MungeDataset1.Rmd</code>, and <code>MungeDatast2.Rmd</code>, and each of these produce R objects <code>dataset1</code> and <code>dataset2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(DataPackageR)
<span class="kw">setwd</span>(<span class="st">"/tmp"</span>)
DataPackageR::<span class="kw"><a href="reference/datapackage.skeleton.html">datapackage.skeleton</a></span>(<span class="st">"MyNewStudy"</span>,<span class="dt">force=</span><span class="ot">TRUE</span>,<span class="dt">code_files =</span> <span class="kw">c</span>(<span class="st">"/tmp/MungeDataset1.Rmd"</span>,<span class="st">"/tmp/MungeDataset2.Rmd"</span>),<span class="dt">r_object_names =</span> <span class="kw">c</span>(<span class="st">"dataset1"</span>,<span class="st">"dataset2"</span>))</code></pre></div>
<pre><code>Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Saving functions and data ...
Making help files ...
Done.
Further steps are described in './MyNewStudy/Read-and-delete-me'.
Adding DataVersion string to DESCRIPTION
Creating data and data-raw directories</code></pre>
<p>The above code creates a directory “MyNewStudy” with the skeleton of a data package.</p>
<p>The <code>DESCRIPTION</code> file should be filled out to describe your package. A new <code>DataVersion</code> string now appears in that file. The revision is automatically incremented if the package data changes.</p>
<p><code>Read-and-delete-me</code> has some helpful instructions on how to proceed.</p>
<p>The <code>data-raw</code> directory is where the data cleaning code (<code>Rmd</code>) files reside. The contents of this directory are:</p>
<pre><code>MyNewStudy/data-raw
└── datasets.R
└── MungeDataset1.Rmd
└── MungeDataset2.Rmd</code></pre>
<p><code>datasets.R</code> can be edited as necessary (see below). This “master” file sources your data munging scripts. Data munging scripts can read data from anywhere, but it is good practice to have your “raw” data live under <code>/inst/extdata</code>. It should be copied into that path and the data munging scripts edited appropriately.</p>
<p>Here are the contents on <code>datasets.R</code>:</p>
<pre><code>pkgName &lt;- roxygen2:::read.description("../DESCRIPTION")$Package

# ------------------------------------------------------------
# Source additional R scripts to preprocess assay data

library(rmarkdown)
render('MungeDataset1.Rmd', envir=topenv(), output_dir='../inst/extdata/Logfiles', clean=FALSE)
render('MungeDataset2.Rmd', envir=topenv(), output_dir='../inst/extdata/Logfiles', clean=FALSE)

# for a systematically-named sequence of scripts, one could do something like this:
# for(fn in list.files(path="./", pattern="^preprocess_.*\\.Rmd$")){
#   render(fn, envir=topenv(),output_dir="../inst/extdata/Logfiles",clean=FALSE)
# }
# Or a full path to each Rmd file can be passed to datapacakge.skeleton via code_files.


# ------------------------------------------------------------
# Define data objects to keep in the package
# (defining here because the list is useful when building roxygen documentation)
objectsToKeep &lt;- c('dataset1', 'dataset2', 'etc.') # if it's a collection of unsystematically-named objects
# objectsToKeep &lt;- ls(pattern=pkgName) # if you can define a rule that describes the naming of objects to be available in the package
# Or these can be passed into datapackage.skeleton via the r_object_names parameter

# ------------------------------------------------------------
# Auto build roxygen documentation
# On first build, we generate boilerplate roxygen documentation using DataPackageR:::.autoDoc()
# User then manually edits the output file edit_and_rename_to_'documentation.R'.R and renames it to documentation.R.
# The documentation.R file is then used for all subsequent builds.
if(file.exists("documentation.R")){
  sys.source('documentation.R', envir=topenv())
} else {
  DataPackageR:::.autoDoc(pkgName, objectsToKeep, topenv())
}

# keep only objects labeled for retention
keepDataObjects(objectsToKeep)  </code></pre>
<p>We look at this piece by piece.</p>
<div id="data-processing-scripts" class="section level3">
<h3 class="hasAnchor">
<a href="#data-processing-scripts" class="anchor"></a>Data processing scripts</h3>
<p>First, we load the rmarkdown package and then render the user-provided data processing code <code>MungeDataset1.Rmd</code>, and <code>MungeDataset2.Rmd</code>.</p>
<ul>
<li>This should (obviously) be an Rmarkdown file, that combines text and R code.</li>
<li>It should contain a YAML preamble with the minimum information needed to process it into an html report.</li>
<li>When run, it should perform the processing of your data sets(s) into an R object named in <code>r_object_names</code> of <code>datapackage.skeleton</code>.</li>
</ul>
<p>The product of this particular script will be an html document that serves as a log of how the data were processed.</p>
<ul>
<li>The html report will be included as a <code>vignette</code> in the final package.</li>
</ul>
<p>The most important product of processing script is one or more R objects.</p>
<ul>
<li>The call to <code><a href="reference/keepDataObjects.html">keepDataObjects()</a></code> tells the build process which objects should be retained and stored as part of the data package.</li>
<li>In this case, our scripts should produce two objects <code>dataset1</code> and <code>dataset2</code>.</li>
<li>
<code><a href="reference/keepDataObjects.html">keepDataObjects('dataset1','dataset2')</a></code> tells the build process the name of the object to store in the package.</li>
<li><p>All this is taken care of via arguments to <code>datapackage.skeleton</code>.</p></li>
<li>You do not need to save these objects to <code>data</code>. The build process will handle this for you.</li>
<li>The objects need to exist in memory when the processing script is finished running.</li>
<li>The build process will match these names to objects in memory and to existing documentation (see below).</li>
<li><p>If everything is in order, they will be included in the built package.</p></li>
</ul>
</div>
<div id="object-documentation" class="section level3">
<h3 class="hasAnchor">
<a href="#object-documentation" class="anchor"></a>Object Documentation</h3>
<p>There is a call to <code>.autoDoc</code>, which generates documentation for the package and the objects on the first run of the build.</p>
<p>It produces a file that the user needs to rename and edit by hand.</p>
<p>The contents of this file are roxygen blocks that are parsed into object and package documentation.</p>
<ul>
<li>It is good practice to
<ul>
<li>Document all the columns of tables in your data set.</li>
<li>Include the source of the data (i.e. where the data came from).</li>
</ul>
</li>
</ul>
</div>
<div id="build-your-package-" class="section level3">
<h3 class="hasAnchor">
<a href="#build-your-package-" class="anchor"></a>Build your package.</h3>
<p>Once your scripts are in place and the data objects are documented, you build the package.</p>
<p>To run the build process:</p>
<pre class="r{}"><code># Within the package directory
DataPackageR:::buildDataSetPackage(".") #note for a first build this needs to be run twice and the 
#documentation edited.</code></pre>
<p>If there are errors, the script will notify you of any problems.</p>
<ul>
<li>Correct any errors and rerun the build process.</li>
</ul>
<p>If everything goes smoothly, you will have a new package built in the parent directory.</p>
<p>This can be distributed, installed using <code>R CMD INSTALL</code>, and data sets loaded using R’s standard <code>data()</code> call. Vignettes can be interrogated via <code>vignette(package="mypackage")</code></p>
</div>
<div id="data-versioning" class="section level3">
<h3 class="hasAnchor">
<a href="#data-versioning" class="anchor"></a>Data versioning</h3>
<p>The DataPackageR package calculates an md5 checksum of each data object it stores, and keeps track of them in a file called <code>DATADIGEST</code>.</p>
<ul>
<li>Each time the package is rebuilt, the md5 sums of the new data objects are compared against the DATADIGEST.</li>
<li>If they don’t match, the build process checks that the <code>DataVersion</code> string has been incremented in the <code>DESCRIPTION</code> file.</li>
<li>If it has not the build process will exit and produce an error message.</li>
</ul>
</div>
<div id="benefits" class="section level3">
<h3 class="hasAnchor">
<a href="#benefits" class="anchor"></a>Benefits</h3>
<p>Your downstream data analysis can depend on a specific version of your data package (for example by tesing the <code>packageVersion()</code> string);</p>
<pre class="r{}"><code>if(packageVersion("MyNewStudy") != "1.0.0")
  stop("The expected version of MyNewStudy is 1.0.0, but ",packageVersion("MyNewStudy")," is installed! Analysis results may differ!")</code></pre>
<p>The DataPackageR packge also provides <code>datasetVersion()</code> to extract the data set version information.</p>
<p>You should also place the data package source directory under <code>git</code> version control. This allows you to version control your data processing code.</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2 class="hasAnchor">
<a href="#sidebar" class="anchor"></a>License</h2>
<p><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></p>
<h2>Developers</h2>
<ul class="list-unstyled">
<li><a href="authors.html">All authors...</a></li>
</ul>
</div>

</div>


      <footer><div class="copyright">
  <p>Developed by .</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
